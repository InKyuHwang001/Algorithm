---
# 2. 구현 문제
---
## 2.7. 럭키 스트레이트

---

- 게임에 피살기가 특정 조건에만 발동 됨
  - 점수가 N(짝수자리수임) 정수 N을 반으로 나누어 왼쪽의 합과 오른쪽 수의 합이 같은 경우
  - 발동시 LUCKY 출력 같지 않으면 READY출력


```python
n=input()
length=len(n)
summary=0
for i in range(length//2):
    summary+=int(n[i])
    
for i in range(length//2, length):
    summary-=int(n[i])
    
if summary==0:
    print("LUCKY")
else:
    print('READY')
```

    775595
    LUCKY


---

## 2.8. 문자열 재정렬

---

- 대문자와 숫자로만 구성된 문자열 입력
- 알파벳이 오름차순으로 나온후 모든 숫자가 더해저 출력됨


```python
data=input()
result=[]
value=0

for x in data:
    if x.isalpha():
        result.append(x)
    else:
        value+=int(x)
    
result.sort()

if value !=0:
    result.append(str(value))
    
print(''.join(result))
```

    A194G6BE
    ABEG20


---

## 2.9. 문자열 압축

---

- https://programmers.co.kr/learn/courses/30/lessons/60057
- 문자열을 압축
  1. "aabbaccc"의 경우 "2a2ba3c"(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)
  2. "ababcdcdababcdcd"의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 "2ab2cd2ab2cd"로 표현가능 "2ababcdcd"로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법
- 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성


```python
#https://programmers.co.kr/learn/courses/30/lessons/60057
def solution(s):
    answer=len(s)
    #1개 단위부터 압축 단위를 늘려가며 확인
    for step in range(1,len(s)//2 +1):
        compressed=''
        prev=s[0:step]
        count=1
        #단위 크기만큼 증가시키며 이전 문자열과 비교
        for j in range(step, len(s),step): #앞에서부터 단위 만큼의 문자열 차출
            #이전 상태와 동일하다면 압축 횟수 증가
            if prev==s[j:j+step]:
                count+=1
            #다른 문자열이 나왔다면
            else:
                compressed+=str(count)+prev if count>=2 else prev
                prev=s[j:j+step] #다시 상태 초기화
                count=1
        #남은 문자열에 대한 처리
        compressed+=str(count)+prev if count>=2 else prev
        #만들어지는 압축 문자열이 가장 짧은 것이 정답
        answer=min(answer,len(compressed))
    return answer
```

---

## 2.10. 자물쇠와 열쇠

---

- https://programmers.co.kr/learn/courses/30/lessons/60059
- 자물쇠는 n,n 열쇠 m,m 
- 열쇠는 회전과 이동이 가능/ 열쇠의 돌기 부분을 자물쇠의 홈에 채우면 열쇠가 열림
- 자물쇠의 모든 홈을 채워 비어 있는 곳이 없어야 됨


```python
#https://programmers.co.kr/learn/courses/30/lessons/60059
def rotate_a_matrix_by_90_degree(a):
    n=len(a)
    m=len(a[0])
    result=[[0]*n for _ in range(m)]
    for i in range(n):
        for j in range(m):
            result[j][n-i-1]=a[i][j]
    return result
def check(new_lock):
    lock_length=len(new_lock)//3
    for i in range(lock_length, lock_length*2):
        for j in range(lock_length, lock_length*2):
            if new_lock[i][j] !=1:
                return False
    return True

def solution(key, lock):
    n=len(lock)
    m=len(key)
    new_lock=[[0]*(n*3)for _ in range(n*3)]
    for i in range(n):
        for j in range(n):
            new_lock[i+n][j+n]=lock[i][j]
        
    for rotation in range(4):
        key=rotate_a_matrix_by_90_degree(key)
        for x in range(n*2):
            for y in range(n*2):
                for i in range(m):
                    for j in range(m):
                        new_lock[x+i][y+j]+=key[i][j]
                if check(new_lock)==True:
                    return True
                for i in range(m):
                    for j in range(m):
                        new_lock[x+i][y+j]-=key[i][j]
    return False
```

