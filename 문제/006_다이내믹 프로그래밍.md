# 다이나믹 프로그래밍

---

## 1.다이나믹 프로그래밍 기초

---
- 중복이 되는 연산을 줄이자
    - 컴퓨터를 활용해도 해결하기 어려운 문제는 시간이 매우 많이 필요하거나 메모리 공간이 많이 필요한 문제이다.
    - 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있다. 이를 다이내믹 프로그래밍이라 함
- 피보나치 수열이 대표적인 예시이다.
### 1.1. 피보나치 함수 코드


```python
#피보나치 함수 재귀 함수로 구현
def fibo(x):
    if x==1 or x==2:
        return 1
    return fibo(x-1) + fibo(x-2)
print(fibo(5))
```

    5


### 1.2. 피보나치 수열 소스코드(재귀적)


```python
#한 번 계산된 결과를 Memoiztion하기 위한 리스트 초기화
d=[0]*100
#피보나치 함수를 재귀함수로 구현
def fibo(x):
    if x==1 or x==2:
        return 1
    #이미 계산한 적 있는 문제라면 그대로 변환
    if d[x] !=0:
        return d[x]
    #아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 변환
    d[x]= fibo(x - 1) + fibo(x - 2)
    return d[x]
print(fibo(99))

```

    218922995834555169026


### 1.3. 호출되는 함수 확인


```python
d = [0]*100
def pibo(x):
    print('f('+str(x)+')', end= ' ')
    if x==1 or x==2:
        return 1
    if d[x]!=0:
        return d[x]
    d[x]=pibo(x-1)+pibo(x-2)
    return d[x]
pibo(6)
```

    f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3) f(4) 




    8



### 1.4. 피보나치 수열 소스코드(반복)


```python
#앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d=[0]*100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1]=1
d[2]=1
n=99

#피보나치 함수 반복문으로 구현(바텀업 방식 다이나믹 프로그래밍)
for i in range(3, n+1):
    d[i]=d[i-1]+d[i-2]

print(d[n])
```

    218922995834555169026


---
## 2. 1로 만들기
---
- 정수 X가 주워짐
    - X가 5로 나누어 떨어지면 5로 나눔
    - X가 3으로 나누어 떨어지면 3으로 나눔
    - X가 2로 나누어 떨어지면 2로 나눔
    - X-1 
- 1로만드는 최소 연산수 출력


```python
# 정수 X 입력
x= int(input())
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d=[0]*30001
# 다이나믹 프로그래밍 진행
for i in range(2, x+1):
    d[i]= d[i-1]+1
    if i%2 ==0:
        d[i]= min(d[i], d[i//2]+1)
    if i%3 ==0:
        d[i]= min(d[i], d[i//3]+1)
    if i%5 ==0:
        d[i]= min(d[i], d[i//5]+1)
print(d[x])
```

    99
    5


---
## 3 약탈
---
- 갑 부족은 식량을 뺏기위해 을 부족을 털려고 한다. 
- 식량창고는 일직선으로 이어지고 선택적으로 털 수 있다.
- 인접창고가 털리면 을 부족은 바로 알라차리기에 1칸 이상 떨어진 부족을 턴다
- 뺏을 수 있는 식향의 최댓값을 구하여라


```python
#정수 N을 입력 받기
n = int(input())
#모든 식량 정보를 입력받기
array=list(map(int, input().split()))

#앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d=[0]*100

#다이나믹 프로그래밍 진행
d[0]=array[0]
d[1]=max(array[0], array[1])
for i in range(2, n):
    d[i]=max(d[i-1], d[i-2]+array[i])
#계산된 결과 출력
print(d[n])
```

    4
    99 100 15 66
    166


---
## 4 바닥공사
---
- 가로길이가 N 세로길이가 2인 직사칵형 타일
- 1*2 2*1 2*2 의 텁개 모든 바닥을 채우는 경우의 수를 구하라
- 첫째줄에 2*N 크기의 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지를 출력한다.(결과값이 커지는 것을 방지)


```python
#정수 N을 입력 받기
n = int(input())

#앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d=[0]*1001

#다이나믹 프로그래밍 진행
d[1]=1
d[2]=3
for i in range(3, n+1):
    d[i]=(d[i-1]+ 2*d[i-2])%796796
#계산된 결과 출력
print(d[n])    
```

    3
    5


---
## 5 효율적 화폐 구성
---
- N개의 화폐 종류/ 이들의 개수를 최소한으로 사용한 그가치의 함이 M이 되록 하려 한다.
- 화폐는 몇개든 사용이 가능하다.
- 조합의 특성을 가진다.


```python
# N,M을 입력받기
n,m =map(int, input().split())
# N개의 화폐 단위 정보를 입력받기
array=[]
for i in range(n):
    array.append(int(input()))
    
# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d=[10001]*(m+1)

# 다이나믹 프로그래밍 진행
d[0]=0
for i in range(n):
    for j in range(array[i],m+1):
        if d[j - array[i]] !=10001: #(i-k)원을 만드는 방법이 존재하는 경우
            d[j]=min(d[j], d[j- array[i]]+1)
            
#걔산된 결과 출력
if d[m]==10001: #최종적으로 M원을 만드는 방법이 없는 경우
    print(-1)
else:
    print(d[m])
```

    2 15
    2
    3
    5

